"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPostResponse = exports.CreatePostResponseError = void 0;
const web3_js_1 = require("@solana/web3.js");
const constants_js_1 = require("./constants.js");
const actionIdentity_js_1 = require("./actionIdentity.js");
/**
 * Thrown when the Action POST response cannot be created.
 */
class CreatePostResponseError extends Error {
    constructor() {
        super(...arguments);
        this.name = "CreatePostResponseError";
    }
}
exports.CreatePostResponseError = CreatePostResponseError;
/**
 * Create the payload to be returned in an Action POST response,
 * including signing and base64 encoding the `transaction`
 *
 * @throws {CreatePostResponseError}
 */
function createPostResponse(args) {
    return __awaiter(this, void 0, void 0, function* () {
        // Auto-magically detect the identity keypair from the env
        if (!args.actionIdentity) {
            try {
                args.actionIdentity = (0, actionIdentity_js_1.getActionIdentityFromEnv)();
            }
            catch (err) {
                // do nothing
            }
        }
        if (isVersionedTransaction(args.fields.transaction)) {
            return prepareVersionedTransaction(args);
        }
        else {
            return prepareLegacyTransaction(args);
        }
    });
}
exports.createPostResponse = createPostResponse;
/**
 * Prepare a `VersionedTransaction` to be sent as the ActionPostResponse
 */
function prepareVersionedTransaction({ fields, signers, reference, actionIdentity, }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (fields.transaction.message.compiledInstructions.length <= 0) {
            throw new CreatePostResponseError("at least 1 instruction is required");
        }
        if (actionIdentity) {
            let message = web3_js_1.TransactionMessage.decompile(fields.transaction.message);
            const { instruction, reference: finalReference } = (0, actionIdentity_js_1.createActionIdentifierInstruction)(actionIdentity, reference);
            message.instructions.push(instruction);
            message.instructions = injectReferencesToInstructions(message.instructions, actionIdentity.publicKey, finalReference);
            // recompile the message correctly based on the original version
            if (fields.transaction.version == "legacy") {
                fields.transaction.message = message.compileToLegacyMessage();
            }
            else {
                fields.transaction.message = message.compileToV0Message();
            }
        }
        if (signers && signers.length)
            fields.transaction.sign(signers);
        return Object.assign(fields, {
            transaction: Buffer.from(fields.transaction.serialize()).toString("base64"),
        });
    });
}
/**
 * Prepare a legacy `Transaction` to be sent as the `ActionPostResponse`
 */
function prepareLegacyTransaction({ fields, signers, reference, actionIdentity, }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (fields.transaction.instructions.length <= 0) {
            throw new CreatePostResponseError("at least 1 instruction is required");
        }
        if (actionIdentity) {
            const { instruction, reference: finalReference } = (0, actionIdentity_js_1.createActionIdentifierInstruction)(actionIdentity, reference);
            fields.transaction.add(instruction);
            fields.transaction.instructions = injectReferencesToInstructions(fields.transaction.instructions, actionIdentity.publicKey, finalReference);
        }
        if (signers && signers.length)
            fields.transaction.partialSign(...signers);
        return Object.assign(fields, {
            transaction: Buffer.from(fields.transaction.serialize({ requireAllSignatures: false })).toString("base64"),
        });
    });
}
function injectReferencesToInstructions(instructions, actionIdentity, reference) {
    // locate a non-memo instruction
    const memoId = new web3_js_1.PublicKey(constants_js_1.MEMO_PROGRAM_ID);
    const nonMemoIndex = instructions.findIndex((ix) => ix.programId.toBase58() !== memoId.toBase58());
    if (nonMemoIndex == -1) {
        throw new CreatePostResponseError("transaction requires at least 1 non-memo instruction");
    }
    // insert the 2 reference keys as non signers
    instructions[nonMemoIndex].keys.push({
        pubkey: actionIdentity,
        isWritable: false,
        isSigner: false,
    });
    instructions[nonMemoIndex].keys.push({
        pubkey: reference,
        isWritable: false,
        isSigner: false,
    });
    return instructions;
}
function isVersionedTransaction(transaction) {
    return "version" in transaction;
}
//# sourceMappingURL=createPostResponse.js.map