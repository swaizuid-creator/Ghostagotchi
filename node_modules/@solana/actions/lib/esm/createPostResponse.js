import { PublicKey, TransactionMessage, } from "@solana/web3.js";
import { MEMO_PROGRAM_ID } from "./constants.js";
import { createActionIdentifierInstruction, getActionIdentityFromEnv, } from "./actionIdentity.js";
/**
 * Thrown when the Action POST response cannot be created.
 */
export class CreatePostResponseError extends Error {
    constructor() {
        super(...arguments);
        this.name = "CreatePostResponseError";
    }
}
/**
 * Create the payload to be returned in an Action POST response,
 * including signing and base64 encoding the `transaction`
 *
 * @throws {CreatePostResponseError}
 */
export async function createPostResponse(args) {
    // Auto-magically detect the identity keypair from the env
    if (!args.actionIdentity) {
        try {
            args.actionIdentity = getActionIdentityFromEnv();
        }
        catch (err) {
            // do nothing
        }
    }
    if (isVersionedTransaction(args.fields.transaction)) {
        return prepareVersionedTransaction(args);
    }
    else {
        return prepareLegacyTransaction(args);
    }
}
/**
 * Prepare a `VersionedTransaction` to be sent as the ActionPostResponse
 */
async function prepareVersionedTransaction({ fields, signers, reference, actionIdentity, }) {
    if (fields.transaction.message.compiledInstructions.length <= 0) {
        throw new CreatePostResponseError("at least 1 instruction is required");
    }
    if (actionIdentity) {
        let message = TransactionMessage.decompile(fields.transaction.message);
        const { instruction, reference: finalReference } = createActionIdentifierInstruction(actionIdentity, reference);
        message.instructions.push(instruction);
        message.instructions = injectReferencesToInstructions(message.instructions, actionIdentity.publicKey, finalReference);
        // recompile the message correctly based on the original version
        if (fields.transaction.version == "legacy") {
            fields.transaction.message = message.compileToLegacyMessage();
        }
        else {
            fields.transaction.message = message.compileToV0Message();
        }
    }
    if (signers && signers.length)
        fields.transaction.sign(signers);
    return Object.assign(fields, {
        transaction: Buffer.from(fields.transaction.serialize()).toString("base64"),
    });
}
/**
 * Prepare a legacy `Transaction` to be sent as the `ActionPostResponse`
 */
async function prepareLegacyTransaction({ fields, signers, reference, actionIdentity, }) {
    if (fields.transaction.instructions.length <= 0) {
        throw new CreatePostResponseError("at least 1 instruction is required");
    }
    if (actionIdentity) {
        const { instruction, reference: finalReference } = createActionIdentifierInstruction(actionIdentity, reference);
        fields.transaction.add(instruction);
        fields.transaction.instructions = injectReferencesToInstructions(fields.transaction.instructions, actionIdentity.publicKey, finalReference);
    }
    if (signers && signers.length)
        fields.transaction.partialSign(...signers);
    return Object.assign(fields, {
        transaction: Buffer.from(fields.transaction.serialize({ requireAllSignatures: false })).toString("base64"),
    });
}
function injectReferencesToInstructions(instructions, actionIdentity, reference) {
    // locate a non-memo instruction
    const memoId = new PublicKey(MEMO_PROGRAM_ID);
    const nonMemoIndex = instructions.findIndex((ix) => ix.programId.toBase58() !== memoId.toBase58());
    if (nonMemoIndex == -1) {
        throw new CreatePostResponseError("transaction requires at least 1 non-memo instruction");
    }
    // insert the 2 reference keys as non signers
    instructions[nonMemoIndex].keys.push({
        pubkey: actionIdentity,
        isWritable: false,
        isSigner: false,
    });
    instructions[nonMemoIndex].keys.push({
        pubkey: reference,
        isWritable: false,
        isSigner: false,
    });
    return instructions;
}
function isVersionedTransaction(transaction) {
    return "version" in transaction;
}
//# sourceMappingURL=createPostResponse.js.map